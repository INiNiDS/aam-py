{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"aam-py","text":"<p>Welcome to the <code>aam-py</code> documentation. This is a Python implementation of the Abstract Alias Mapping (AAM) parser and configuration system.</p>","path":["aam-py"],"tags":[]},{"location":"#overview","level":2,"title":"Overview","text":"<p>The <code>aam-py</code> library is designed to parse AAML (Abstract Alias Mapping Language) files, validate their schemas, correctly assign data types, and expose an easy-to-use querying system for those configurations.</p>","path":["aam-py"],"tags":[]},{"location":"#installation","level":2,"title":"Installation","text":"<pre><code>pip install aam-py\n</code></pre>","path":["aam-py"],"tags":[]},{"location":"#quick-start","level":2,"title":"Quick Start","text":"<pre><code>from aam_py.builder import AAMBuilder, SchemaField\nfrom aam_py.types.primitive import PrimitiveType\n\nbuilder = AAMBuilder()\nbuilder.add_schema(\n    SchemaField(\"host\", PrimitiveType.String),\n    SchemaField(\"port\", PrimitiveType.Integer)\n)\n\nparser = builder.build()\naaml = parser.parse_file(\"config.aaml\")\n\nprint(aaml.get(\"host\").as_string())\nprint(aaml.get(\"port\").as_integer())\n</code></pre>","path":["aam-py"],"tags":[]},{"location":"error/","level":1,"title":"Errors","text":"<p>The <code>aam-py</code> hierarchy of Error definitions used throughout interpreting and validation.</p>","path":["Errors"],"tags":[]},{"location":"error/#aamlerror","level":2,"title":"AamlError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.AamlError","level":2,"title":"<code>aam_py.error.AamlError</code>","text":"<p>Base exception for all AAML errors.</p> Source code in <code>aam_py/error.py</code> <pre><code>class AamlError(Exception):\n    \"\"\"Base exception for all AAML errors.\"\"\"\n    pass\n</code></pre>","path":["Errors"],"tags":[]},{"location":"error/#parseerror","level":2,"title":"ParseError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.ParseError","level":2,"title":"<code>aam_py.error.ParseError</code>","text":"<p>A line could not be parsed as a valid AAML statement.</p> Source code in <code>aam_py/error.py</code> <pre><code>class ParseError(AamlError):\n    \"\"\"A line could not be parsed as a valid AAML statement.\"\"\"\n    __slots__ = ('line', 'content', 'details')\n\n    def __init__(self, line: int, content: str, details: str):\n        self.line = line\n        self.content = content\n        self.details = details\n        super().__init__(f\"Parse Error at line {line}: '{content}'. Reason: {details}\")\n</code></pre>","path":["Errors"],"tags":[]},{"location":"error/#ioerror","level":2,"title":"IoError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.IoError","level":2,"title":"<code>aam_py.error.IoError</code>","text":"<p>An I/O error occurred while reading a file.</p> Source code in <code>aam_py/error.py</code> <pre><code>class IoError(AamlError):\n    \"\"\"An I/O error occurred while reading a file.\"\"\"\n    def __init__(self, message: str):\n        super().__init__(f\"IO Error: {message}\")\n</code></pre>","path":["Errors"],"tags":[]},{"location":"error/#notfounderror","level":2,"title":"NotFoundError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.NotFoundError","level":2,"title":"<code>aam_py.error.NotFoundError</code>","text":"<p>A key or type name was not found in the registry or map.</p> Source code in <code>aam_py/error.py</code> <pre><code>class NotFoundError(AamlError):\n    \"\"\"A key or type name was not found in the registry or map.\"\"\"\n    __slots__ = ('key',)\n\n    def __init__(self, key: str):\n        self.key = key\n        super().__init__(f\"Key not found: '{key}'\")\n</code></pre>","path":["Errors"],"tags":[]},{"location":"error/#invalidvalueerror","level":2,"title":"InvalidValueError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.InvalidValueError","level":2,"title":"<code>aam_py.error.InvalidValueError</code>","text":"<p>A value does not satisfy a basic type constraint.</p> Source code in <code>aam_py/error.py</code> <pre><code>class InvalidValueError(AamlError):\n    \"\"\"A value does not satisfy a basic type constraint.\"\"\"\n    def __init__(self, message: str):\n        super().__init__(f\"Invalid value: {message}\")\n</code></pre>","path":["Errors"],"tags":[]},{"location":"error/#invalidtypeerror","level":2,"title":"InvalidTypeError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.InvalidTypeError","level":2,"title":"<code>aam_py.error.InvalidTypeError</code>","text":"<p>A value failed validation against a registered or built-in type.</p> Source code in <code>aam_py/error.py</code> <pre><code>class InvalidTypeError(AamlError):\n    \"\"\"A value failed validation against a registered or built-in type.\"\"\"\n    __slots__ = ('type_name', 'details')\n\n    def __init__(self, type_name: str, details: str):\n        self.type_name = type_name\n        self.details = details\n        super().__init__(f\"Invalid type '{type_name}': {details}\")\n</code></pre>","path":["Errors"],"tags":[]},{"location":"error/#directiveerror","level":2,"title":"DirectiveError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.DirectiveError","level":2,"title":"<code>aam_py.error.DirectiveError</code>","text":"<p>A directive encountered an error in its arguments.</p> Source code in <code>aam_py/error.py</code> <pre><code>class DirectiveError(AamlError):\n    \"\"\"A directive encountered an error in its arguments.\"\"\"\n    __slots__ = ('cmd', 'msg')\n\n    def __init__(self, cmd: str, msg: str):\n        self.cmd = cmd\n        self.msg = msg\n        super().__init__(f\"Directive '@{cmd}' error: {msg}\")\n</code></pre>","path":["Errors"],"tags":[]},{"location":"error/#schemavalidationerror","level":2,"title":"SchemaValidationError","text":"","path":["Errors"],"tags":[]},{"location":"error/#aam_py.error.SchemaValidationError","level":2,"title":"<code>aam_py.error.SchemaValidationError</code>","text":"<p>A schema constraint was violated during parsing or explicit validation.</p> Source code in <code>aam_py/error.py</code> <pre><code>class SchemaValidationError(AamlError):\n    \"\"\"A schema constraint was violated during parsing or explicit validation.\"\"\"\n    __slots__ = ('schema', 'field', 'type_name', 'details')\n\n    def __init__(self, schema: str, field: str, type_name: str, details: str):\n        self.schema = schema\n        self.field = field\n        self.type_name = type_name\n        self.details = details\n        super().__init__(f\"Schema '{schema}' validation error: field '{field}' (type '{type_name}') — {details}\")\n</code></pre>","path":["Errors"],"tags":[]},{"location":"api/","level":1,"title":"API Reference","text":"<p>The <code>aam-py</code> API exposes several core components:</p> <ul> <li>Core &amp; Building: <code>AAML</code> structure, <code>AAMBuilder</code> configuration builder, <code>SchemaField</code>.</li> <li>Parsing &amp; Values: Token parsing and the <code>FoundValue</code> struct which wraps the typed values.</li> <li>Validation: Enforcing schema validation.</li> <li>Types: Base types, Primitive Types, List Types, Maty Types, Time Types, and Complex Types.</li> <li>Commands: Handlers for custom commands (<code>@import</code>, <code>@derive</code>).</li> </ul>","path":["API Reference"],"tags":[]},{"location":"api/commands/","level":1,"title":"Commands","text":"","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#import-command","level":2,"title":"Import Command","text":"","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#aam_py.commands.import_cmd.ImportCommand","level":2,"title":"<code>aam_py.commands.import_cmd.ImportCommand</code>","text":"Source code in <code>aam_py/commands/import_cmd.py</code> <pre><code>class ImportCommand:\n    @property\n    def name(self) -&gt; str:\n        return \"import\"\n\n    def execute(self, aaml: 'AAML', args: str) -&gt; None:\n        path = aaml.unwrap_quotes(args.strip())\n        if not path:\n            raise ParseError(0, f\"@import {args}\", \"Missing file path\")\n        aaml.merge_file(path)\n</code></pre>","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#derive-command","level":2,"title":"Derive Command","text":"","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#aam_py.commands.derive.DeriveCommand","level":2,"title":"<code>aam_py.commands.derive.DeriveCommand</code>","text":"Source code in <code>aam_py/commands/derive.py</code> <pre><code>class DeriveCommand:\n    @property\n    def name(self) -&gt; str:\n        return \"derive\"\n\n    def execute(self, aaml: 'AAML', args: str) -&gt; None:\n        parts = [p.strip() for p in args.split('::')]\n        if not parts or not parts[0]:\n            raise ParseError(0, f\"@derive {args}\", \"Missing file path\")\n\n        file_path = aaml.unwrap_quotes(parts[0])\n        schema_names = parts[1:]\n\n        # We need a new AAML instance to parse the base file\n        from aam_py.aaml import AAML\n        try:\n            base_config = AAML.load(file_path)\n        except Exception as e:\n            raise ParseError(0, f\"@derive {args}\", f\"Failed to load derived file: {e}\")\n\n        if schema_names:\n            # We ONLY copy the keys defined by the specified schemas\n            for name in schema_names:\n                schema_def = base_config.get_schema(name)\n                if not schema_def:\n                    raise ParseError(0, f\"@derive {args}\", f\"Schema '{name}' not found in '{file_path}'\")\n\n                aaml._schemas[name] = schema_def\n\n                for field in schema_def.fields:\n                    val = base_config.get_map().get(field)\n                    if val is not None:\n                        aaml.get_map().setdefault(field, val)\n        else:\n            # Inherit everything but do not overwrite existing keys\n            for k, v in base_config.get_map().items():\n                aaml.get_map().setdefault(k, v)\n\n            # Copy schemas and types as well\n            for k, v in base_config._schemas.items():\n                if k not in aaml._schemas:\n                    aaml._schemas[k] = v\n            for k, v in base_config._types.items():\n                if k not in aaml._types:\n                    aaml._types[k] = v\n\n        # Validate completeness\n        if schema_names:\n            from aam_py.validation import validate_schemas_completeness_for\n            validate_schemas_completeness_for(base_config, schema_names)\n\n        from aam_py.validation import validate_schemas_completeness\n        validate_schemas_completeness(aaml)\n</code></pre>","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#schema-command","level":2,"title":"Schema Command","text":"","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#aam_py.commands.schema_cmd.SchemaCommand","level":2,"title":"<code>aam_py.commands.schema_cmd.SchemaCommand</code>","text":"Source code in <code>aam_py/commands/schema_cmd.py</code> <pre><code>class SchemaCommand:\n    @property\n    def name(self) -&gt; str:\n        return \"schema\"\n\n    def execute(self, aaml: 'AAML', args: str) -&gt; None:\n        parts = args.split('{', 1)\n        if len(parts) != 2 or '}' not in parts[1]:\n            raise ParseError(0, f\"@schema {args}\", \"Expected block enclosed in {...}\")\n\n        name = parts[0].strip()\n        body = parts[1].rsplit('}', 1)[0].strip()\n\n        if not name:\n            raise ParseError(0, f\"@schema {args}\", \"Schema name cannot be empty\")\n\n        fields = {}\n        optional_fields = []\n\n        if body:\n            from aam_py.parsing import split_top_level_fields, split_field_pair\n            items = split_top_level_fields(body)\n            for item in items:\n                item = item.strip()\n                if not item:\n                    continue\n                try:\n                    k, v = split_field_pair(item)\n                except ValueError:\n                    raise ParseError(0, item, \"Invalid schema field (missing ':' or '=')\")\n\n                k = k.strip()\n                type_name = v.strip()\n\n                if k.endswith('*'):\n                    field_name = k[:-1].strip()\n                    optional_fields.append(field_name)\n                else:\n                    field_name = k\n\n                if not field_name:\n                    raise ParseError(0, item, \"Empty field name\")\n\n                fields[field_name] = type_name\n\n        aaml._schemas[name] = SchemaDef(fields, optional_fields)\n</code></pre>","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#type-command","level":2,"title":"Type Command","text":"","path":["API Reference","Commands"],"tags":[]},{"location":"api/commands/#aam_py.commands.type_cmd.TypeCommand","level":2,"title":"<code>aam_py.commands.type_cmd.TypeCommand</code>","text":"Source code in <code>aam_py/commands/type_cmd.py</code> <pre><code>class TypeCommand:\n    @property\n    def name(self) -&gt; str:\n        return \"type\"\n\n    def execute(self, aaml: 'AAML', args: str) -&gt; None:\n        parts = [p.strip() for p in args.split('=', 1)]\n        if len(parts) != 2:\n            raise ParseError(0, f\"@type {args}\", \"Expected format: @type alias = type_name\")\n\n        alias = parts[0]\n        type_name = parts[1]\n\n        if not alias or not type_name:\n            raise ParseError(0, f\"@type {args}\", \"Alias and type name cannot be empty\")\n\n        type_def = aaml.get_type(type_name)\n        if type_def is not None:\n            aaml.register_type(alias, type_def)\n            return\n\n        try:\n            builtin = resolve_builtin(type_name)\n            aaml.register_type(alias, builtin)\n        except NotFoundError:\n            raise ParseError(0, f\"@type {args}\", f\"Unknown type to alias: '{type_name}'\")\n</code></pre>","path":["API Reference","Commands"],"tags":[]},{"location":"api/core/","level":1,"title":"Core &amp; Building","text":"","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#aambuilder","level":2,"title":"AAMBuilder","text":"","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#aam_py.builder.AAMBuilder","level":2,"title":"<code>aam_py.builder.AAMBuilder</code>","text":"<p>Fluent builder for constructing AAML configuration content programmatically.</p> Source code in <code>aam_py/builder.py</code> <pre><code>class AAMBuilder:\n    \"\"\"Fluent builder for constructing AAML configuration content programmatically.\"\"\"\n    __slots__ = ('_buffer',)\n\n    def __init__(self):\n        self._buffer: List[str] = []\n\n    def _push_sep(self) -&gt; None:\n        if self._buffer:\n            self._buffer.append('\\n')\n\n    def add_line(self, key: str, value: str) -&gt; 'AAMBuilder':\n        self._push_sep()\n        self._buffer.append(f\"{key} = {value}\")\n        return self\n\n    def comment(self, text: str) -&gt; 'AAMBuilder':\n        self._push_sep()\n        self._buffer.append(f\"# {text}\")\n        return self\n\n    def schema(self, name: str, fields: Iterable[SchemaField]) -&gt; 'AAMBuilder':\n        self._push_sep()\n        fields_str = \", \".join(f.to_aaml() for f in fields)\n        self._buffer.append(f\"@schema {name} {{ {fields_str} }}\")\n        return self\n\n    def schema_multiline(self, name: str, fields: Iterable[SchemaField]) -&gt; 'AAMBuilder':\n        self._push_sep()\n        self._buffer.append(f\"@schema {name} {{\")\n        for field in fields:\n            self._buffer.append(f\"\\n    {field.to_aaml()}\")\n        self._buffer.append(\"\\n}\")\n        return self\n\n    def derive(self, path: str, schemas: Iterable[str] = ()) -&gt; 'AAMBuilder':\n        self._push_sep()\n        base = f\"@derive {path}\"\n        schemas_list = list(schemas)\n        if schemas_list:\n            base += \"::\" + \"::\".join(schemas_list)\n        self._buffer.append(base)\n        return self\n\n    def import_path(self, path: str) -&gt; 'AAMBuilder':\n        self._push_sep()\n        self._buffer.append(f\"@import {path}\")\n        return self\n\n    def type_alias(self, alias: str, type_name: str) -&gt; 'AAMBuilder':\n        self._push_sep()\n        self._buffer.append(f\"@type {alias} = {type_name}\")\n        return self\n\n    def add_raw(self, raw_line: str) -&gt; 'AAMBuilder':\n        self._push_sep()\n        self._buffer.append(raw_line)\n        return self\n\n    def to_file(self, path: Union[str, os.PathLike]) -&gt; None:\n        with open(path, 'w', encoding='utf-8') as f:\n            f.write(\"\".join(self._buffer))\n\n    def build(self) -&gt; str:\n        return \"\".join(self._buffer)\n\n    def __str__(self) -&gt; str:\n        return self.build()\n</code></pre>","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#schemafield","level":2,"title":"SchemaField","text":"","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#aam_py.builder.SchemaField","level":2,"title":"<code>aam_py.builder.SchemaField</code>","text":"<p>A single field declaration inside a <code>@schema</code> block.</p> Source code in <code>aam_py/builder.py</code> <pre><code>class SchemaField:\n    \"\"\"A single field declaration inside a `@schema` block.\"\"\"\n    __slots__ = ('name', 'type_name', 'is_optional')\n\n    def __init__(self, name: str, type_name: str, is_optional: bool = False):\n        self.name = name\n        self.type_name = type_name\n        self.is_optional = is_optional\n\n    @classmethod\n    def required(cls, name: str, type_name: str) -&gt; 'SchemaField':\n        return cls(name, type_name, False)\n\n    @classmethod\n    def optional(cls, name: str, type_name: str) -&gt; 'SchemaField':\n        return cls(name, type_name, True)\n\n    def to_aaml(self) -&gt; str:\n        if self.is_optional:\n            return f\"{self.name}*: {self.type_name}\"\n        return f\"{self.name}: {self.type_name}\"\n</code></pre>","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#schemadef","level":2,"title":"SchemaDef","text":"","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#aam_py.aaml.SchemaDef","level":2,"title":"<code>aam_py.aaml.SchemaDef</code>","text":"<p>Represents a schema definition structure.</p> Source code in <code>aam_py/aaml.py</code> <pre><code>class SchemaDef:\n    \"\"\"Represents a schema definition structure.\"\"\"\n    __slots__ = ('fields', 'optional_fields')\n\n    def __init__(self, fields: Dict[str, str], optional_fields: List[str]):\n        self.fields = fields\n        self.optional_fields = set(optional_fields)\n\n    def is_optional(self, field: str) -&gt; bool:\n        return field in self.optional_fields\n</code></pre>","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#aaml","level":2,"title":"AAML","text":"","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/core/#aam_py.aaml.AAML","level":2,"title":"<code>aam_py.aaml.AAML</code>","text":"<p>The main AAML parser and configuration store.</p> Source code in <code>aam_py/aaml.py</code> <pre><code>class AAML:\n    \"\"\"\n    The main AAML parser and configuration store.\n    \"\"\"\n    __slots__ = ('_map', '_commands', '_types', '_schemas')\n\n    def __init__(self):\n        self._map: Dict[str, str] = {}\n        self._commands: Dict[str, Command] = {}\n        self._types: Dict[str, Type] = {}\n        self._schemas: Dict[str, SchemaDef] = {}\n        self._register_default_commands()\n\n    # Accessors used by commands\n    def get_schemas(self) -&gt; Dict[str, SchemaDef]:\n        return self._schemas\n\n    def get_schema(self, name: str) -&gt; Optional[SchemaDef]:\n        return self._schemas.get(name)\n\n    def get_map(self) -&gt; Dict[str, str]:\n        return self._map\n\n    # Type registry\n    def register_command(self, command: Command) -&gt; None:\n        self._commands[command.name] = command\n\n    def register_type(self, name: str, type_def: Type) -&gt; None:\n        self._types[name] = type_def\n\n    def get_type(self, name: str) -&gt; Optional[Type]:\n        return self._types.get(name)\n\n    def unregister_type(self, name: str) -&gt; None:\n        self._types.pop(name, None)\n\n    def check_type(self, type_name: str, value: str) -&gt; None:\n        type_def = self._types.get(type_name)\n        if type_def is None:\n            raise NotFoundError(type_name)\n        type_def.validate(value)\n\n    def validate_value(self, type_name: str, value: str) -&gt; None:\n        try:\n            type_def = self._types.get(type_name)\n            if type_def is not None:\n                type_def.validate(value)\n                return\n\n            builtin = resolve_builtin(type_name)\n            builtin.validate(value)\n        except AamlError as e:\n            raise InvalidTypeError(type_name, str(e))\n\n    # Parsing\n    def merge_content(self, content: str) -&gt; None:\n        pending: Optional[Tuple[List[str], int]] = None\n\n        for i, line in enumerate(content.splitlines()):\n            line_num = i + 1\n            result = self._accumulate_or_process(line, line_num, pending)\n            if isinstance(result, tuple) and isinstance(result[0], str):\n                complete, start_line = result\n                self._process_line(complete, start_line)\n                pending = None\n            elif result is not None:\n                # result is a list tuple or None\n                pending = result\n\n        if pending is not None:\n            buf, start = pending\n            self._process_line(' '.join(buf), start)\n\n    def _accumulate_or_process(self, line: str, line_num: int, pending: Optional[Tuple[List[str], int]]) -&gt; Optional[Tuple]:\n        if pending is not None:\n            buf, start = pending\n            buf.append(strip_comment(line).strip())\n            joined = ' '.join(buf)\n            if block_is_complete(joined):\n                return (joined, start)\n            return pending\n\n        stripped = strip_comment(line).strip()\n        if needs_accumulation(stripped):\n            return ([stripped], line_num)\n\n        self._process_line(line, line_num)\n        return pending\n\n    def merge_file(self, file_path: str) -&gt; None:\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n            self.merge_content(content)\n        except IOError as e:\n            from aam_py.error import IoError as AamlIoError\n            raise AamlIoError(str(e))\n\n    @classmethod\n    def parse(cls, content: str) -&gt; 'AAML':\n        instance = cls()\n        instance.merge_content(content)\n        return instance\n\n    @classmethod\n    def load(cls, file_path: str) -&gt; 'AAML':\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n            return cls.parse(content)\n        except IOError as e:\n            from aam_py.error import IoError as AamlIoError\n            raise AamlIoError(str(e))\n\n    @staticmethod\n    def unwrap_quotes(s: str) -&gt; str:\n        return unwrap_quotes(s)\n\n    def _register_default_commands(self) -&gt; None:\n        from aam_py.commands.import_cmd import ImportCommand\n        from aam_py.commands.type_cmd import TypeCommand\n        from aam_py.commands.schema_cmd import SchemaCommand\n        from aam_py.commands.derive import DeriveCommand\n\n        self.register_command(ImportCommand())\n        self.register_command(TypeCommand())\n        self.register_command(SchemaCommand())\n        self.register_command(DeriveCommand())\n\n    def _process_line(self, raw_line: str, line_num: int) -&gt; None:\n        line = strip_comment(raw_line).strip()\n        if not line:\n            return\n        if line.startswith('@'):\n            self._process_directive(line[1:], line_num)\n            return\n        self._process_assignment(line, line_num)\n\n    def _process_assignment(self, line: str, line_num: int) -&gt; None:\n        try:\n            key, value = parse_assignment(line)\n            from aam_py.validation import validate_against_schemas\n            validate_against_schemas(self, key, value)\n            self._map[key] = value\n        except Exception as e:\n            if isinstance(e, AamlError):\n                raise\n            raise ParseError(line_num, line, str(e))\n\n    def _process_directive(self, content: str, line_num: int) -&gt; None:\n        parts = content.split(None, 1)\n        command_name = parts[0].strip() if parts else \"\"\n        args = parts[1] if len(parts) &gt; 1 else \"\"\n\n        if not command_name:\n            raise ParseError(line_num, content, \"Empty directive\")\n\n        cmd = self._commands.get(command_name)\n        if cmd is not None:\n            cmd.execute(self, args)\n        else:\n            raise ParseError(line_num, content, f\"Unknown directive: @{command_name}\")\n\n    def __add__(self, other: 'AAML') -&gt; 'AAML':\n        res = AAML()\n        res._map.update(self._map)\n        res._commands.update(self._commands)\n        res._types.update(self._types)\n        res._schemas.update(self._schemas)\n\n        res._map.update(other._map)\n        res._types.update(other._types)\n        return res\n\n    def __iadd__(self, other: 'AAML') -&gt; 'AAML':\n        self._map.update(other._map)\n        self._types.update(other._types)\n        return self\n\n    # Lookup Methods\n    def find_obj(self, key: str) -&gt; Optional[FoundValue]:\n        if key in self._map:\n            return FoundValue(self._map[key])\n        return self.find_key(key)\n\n    def find_key(self, value: str) -&gt; Optional[FoundValue]:\n        for k, v in self._map.items():\n            if v == value:\n                return FoundValue(k)\n        return None\n\n    def find_deep(self, key: str) -&gt; Optional[FoundValue]:\n        current_key = key\n        last_found = None\n        visited = set()\n\n        while current_key in self._map:\n            if current_key in visited:\n                break\n            visited.add(current_key)\n            next_val = self._map[current_key]\n\n            if next_val in visited:\n                if last_found is None:\n                    last_found = next_val\n                break\n\n            last_found = next_val\n            current_key = next_val\n\n        return FoundValue(last_found) if last_found is not None else None\n</code></pre>","path":["API Reference","Core &amp; Building"],"tags":[]},{"location":"api/parsing/","level":1,"title":"Parsing &amp; Values","text":"","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#parsing-utilities","level":2,"title":"Parsing Utilities","text":"","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing","level":2,"title":"<code>aam_py.parsing</code>","text":"","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.block_is_complete","level":3,"title":"<code>aam_py.parsing.block_is_complete(buf)</code>","text":"<p>Returns True if the buffer has at least as many <code>}</code> as <code>{</code>.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def block_is_complete(buf: str) -&gt; bool:\n    \"\"\"Returns True if the buffer has at least as many `}` as `{`.\"\"\"\n    opens = buf.count('{')\n    closes = buf.count('}')\n    return closes &gt;= opens\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.is_inline_object","level":3,"title":"<code>aam_py.parsing.is_inline_object(value)</code>","text":"<p>Returns True if value is an inline object literal { ... }.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def is_inline_object(value: str) -&gt; bool:\n    \"\"\"Returns True if value is an inline object literal { ... }.\"\"\"\n    v = value.strip()\n    return v.startswith('{') and v.endswith('}')\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.needs_accumulation","level":3,"title":"<code>aam_py.parsing.needs_accumulation(text)</code>","text":"<p>Returns True if text is a directive opening a block not yet closed.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def needs_accumulation(text: str) -&gt; bool:\n    \"\"\"Returns True if text is a directive opening a block not yet closed.\"\"\"\n    if not text.startswith('@'):\n        return False\n    opens = text.count('{')\n    closes = text.count('}')\n    return opens &gt; closes\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.parse_assignment","level":3,"title":"<code>aam_py.parsing.parse_assignment(line)</code>","text":"<p>Parses a <code>key = value</code> assignment and returns trimmed (key, value). Raises ValueError with error message string on failure.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def parse_assignment(line: str) -&gt; Tuple[str, str]:\n    \"\"\"\n    Parses a `key = value` assignment and returns trimmed (key, value).\n    Raises ValueError with error message string on failure.\n    \"\"\"\n    depth = 0\n    eq_pos = -1\n\n    for i, ch in enumerate(line):\n        if ch in ('{', '['):\n            depth += 1\n        elif ch in ('}', ']'):\n            depth -= 1\n        elif ch == '=' and depth == 0:\n            eq_pos = i\n            break\n\n    if eq_pos == -1:\n        raise ValueError(\"Missing assignment operator '='\")\n\n    key = line[:eq_pos].strip()\n    raw_val = line[eq_pos + 1:].strip()\n\n    if not key:\n        raise ValueError(\"Key cannot be empty\")\n\n    if raw_val.startswith('{') or raw_val.startswith('['):\n        val = raw_val\n    else:\n        val = unwrap_quotes(raw_val)\n\n    return key, val\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.parse_inline_object","level":3,"title":"<code>aam_py.parsing.parse_inline_object(value)</code>","text":"<p>Parses an inline object { key = val, ... } into key-value pairs. Returns structurally equivalent pairs of (key, string).</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def parse_inline_object(value: str) -&gt; List[Tuple[str, str]]:\n    \"\"\"\n    Parses an inline object { key = val, ... } into key-value pairs.\n    Returns structurally equivalent pairs of (key, string).\n    \"\"\"\n    s = value.strip()\n    if not s.startswith('{') or not s.endswith('}'):\n        raise ValueError(f\"Inline object must be wrapped in '{{}}', got: '{value}'\")\n\n    inner = s[1:-1]\n    fields = []\n\n    for entry in split_top_level_fields(inner):\n        entry_trimmed = entry.strip()\n        if not entry_trimmed:\n            continue\n\n        k, v = split_field_pair(entry_trimmed)\n        k = k.strip()\n        v_trimmed = v.strip()\n\n        if v_trimmed.startswith('{') or v_trimmed.startswith('['):\n            v_val = v_trimmed\n        else:\n            v_val = unwrap_quotes(v_trimmed)\n\n        if not k:\n            raise ValueError(f\"Empty key in inline object field '{entry_trimmed}'\")\n\n        fields.append((k, v_val))\n\n    return fields\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.split_field_pair","level":3,"title":"<code>aam_py.parsing.split_field_pair(entry)</code>","text":"<p>Splits 'key = val' or 'key: val' on the first = or : at depth 0.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def split_field_pair(entry: str) -&gt; Tuple[str, str]:\n    \"\"\"Splits 'key = val' or 'key: val' on the first = or : at depth 0.\"\"\"\n    depth = 0\n    for i, ch in enumerate(entry):\n        if ch in ('{', '['):\n            depth += 1\n        elif ch in ('}', ']'):\n            depth -= 1\n        elif ch in ('=', ':') and depth == 0:\n            return entry[:i], entry[i + 1:]\n\n    raise ValueError(f\"Inline object field '{entry}' has no '=' or ':' separator\")\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.split_top_level_fields","level":3,"title":"<code>aam_py.parsing.split_top_level_fields(s)</code>","text":"<p>Splits <code>s</code> on commas that are not inside <code>{}</code> or <code>[]</code>.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def split_top_level_fields(s: str) -&gt; List[str]:\n    \"\"\"Splits `s` on commas that are not inside `{}` or `[]`.\"\"\"\n    items = []\n    depth = 0\n    cur = []\n\n    for ch in s:\n        if ch in ('{', '['):\n            depth += 1\n            cur.append(ch)\n        elif ch in ('}', ']'):\n            depth -= 1\n            cur.append(ch)\n        elif ch == ',' and depth == 0:\n            items.append(''.join(cur))\n            cur.clear()\n        else:\n            cur.append(ch)\n\n    items.append(''.join(cur))\n    return items\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.strip_comment","level":3,"title":"<code>aam_py.parsing.strip_comment(line)</code>","text":"<p>Strips an inline <code>#</code> comment from a raw source line, respecting quoted strings.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def strip_comment(line: str) -&gt; str:\n    \"\"\"Strips an inline `#` comment from a raw source line, respecting quoted strings.\"\"\"\n    quote_state = None\n\n    for idx, c in enumerate(line):\n        if quote_state is None and c == '#':\n            preceded_by_space = idx == 0 or line[idx - 1].isspace()\n            followed_by_space = idx + 1 == len(line) or line[idx + 1].isspace()\n            if preceded_by_space and followed_by_space:\n                return line[:idx]\n\n        elif quote_state is None and c in ('\"', \"'\"):\n            quote_state = c\n        elif quote_state == c:\n            quote_state = None\n\n    return line\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.parsing.unwrap_quotes","level":3,"title":"<code>aam_py.parsing.unwrap_quotes(s)</code>","text":"<p>Strips a matching pair of surrounding <code>\"…\"</code> or <code>'…'</code> quotes from <code>s</code>.</p> Source code in <code>aam_py/parsing.py</code> <pre><code>def unwrap_quotes(s: str) -&gt; str:\n    \"\"\"Strips a matching pair of surrounding `\"…\"` or `'…'` quotes from `s`.\"\"\"\n    s = s.strip()\n    if len(s) &gt;= 2:\n        if s.startswith('\"') and s.endswith('\"'):\n            return s[1:-1]\n        if s.startswith(\"'\") and s.endswith(\"'\"):\n            return s[1:-1]\n    return s\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#foundvalue","level":2,"title":"FoundValue","text":"","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.found_value.FoundValue","level":2,"title":"<code>aam_py.found_value.FoundValue</code>","text":"<p>Lookup result wrapper. It can be used like a normal string, but provides helper methods for modification similar to the Rust FoundValue.</p> Source code in <code>aam_py/found_value.py</code> <pre><code>class FoundValue(UserString):\n    \"\"\"\n    Lookup result wrapper.\n    It can be used like a normal string, but provides helper methods\n    for modification similar to the Rust FoundValue.\n    \"\"\"\n    __slots__ = ()\n\n    def __init__(self, seq: str):\n        super().__init__(seq)\n\n    def remove(self, sub: str) -&gt; None:\n        \"\"\"Removes all occurrences of `sub` from the string in-place.\"\"\"\n        self.data = self.data.replace(sub, \"\")\n\n    def as_str(self) -&gt; str:\n        \"\"\"Returns the underlying string.\"\"\"\n        return self.data\n\n    def __repr__(self) -&gt; str:\n        return repr(self.data)\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.found_value.FoundValue.as_str","level":3,"title":"<code>aam_py.found_value.FoundValue.as_str()</code>","text":"<p>Returns the underlying string.</p> Source code in <code>aam_py/found_value.py</code> <pre><code>def as_str(self) -&gt; str:\n    \"\"\"Returns the underlying string.\"\"\"\n    return self.data\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/parsing/#aam_py.found_value.FoundValue.remove","level":3,"title":"<code>aam_py.found_value.FoundValue.remove(sub)</code>","text":"<p>Removes all occurrences of <code>sub</code> from the string in-place.</p> Source code in <code>aam_py/found_value.py</code> <pre><code>def remove(self, sub: str) -&gt; None:\n    \"\"\"Removes all occurrences of `sub` from the string in-place.\"\"\"\n    self.data = self.data.replace(sub, \"\")\n</code></pre>","path":["API Reference","Parsing &amp; Values"],"tags":[]},{"location":"api/types/","level":1,"title":"Types","text":"<p>The type system is composed of an abstract base class <code>Type</code> and several classes encoding distinct type families.</p>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#base-definition","level":2,"title":"Base Definition","text":"","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.Type","level":2,"title":"<code>aam_py.types.Type</code>","text":"<p>Core class that every AAML type must implement.</p> Source code in <code>aam_py/types/__init__.py</code> <pre><code>class Type:\n    \"\"\"Core class that every AAML type must implement.\"\"\"\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; 'Type':\n        \"\"\"Constructs the type from a name string.\"\"\"\n        raise NotImplementedError\n\n    def base_type(self) -&gt; 'Type':\n        \"\"\"Returns the primitive type that best represents this type.\"\"\"\n        raise NotImplementedError\n\n    def validate(self, value: str) -&gt; None:\n        \"\"\"Validates `value` against this type's constraints.\n        Raises AamlError on failure.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.Type.base_type","level":3,"title":"<code>aam_py.types.Type.base_type()</code>","text":"<p>Returns the primitive type that best represents this type.</p> Source code in <code>aam_py/types/__init__.py</code> <pre><code>def base_type(self) -&gt; 'Type':\n    \"\"\"Returns the primitive type that best represents this type.\"\"\"\n    raise NotImplementedError\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.Type.from_name","level":3,"title":"<code>aam_py.types.Type.from_name(name)</code>  <code>classmethod</code>","text":"<p>Constructs the type from a name string.</p> Source code in <code>aam_py/types/__init__.py</code> <pre><code>@classmethod\ndef from_name(cls, name: str) -&gt; 'Type':\n    \"\"\"Constructs the type from a name string.\"\"\"\n    raise NotImplementedError\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.Type.validate","level":3,"title":"<code>aam_py.types.Type.validate(value)</code>","text":"<p>Validates <code>value</code> against this type's constraints. Raises AamlError on failure.</p> Source code in <code>aam_py/types/__init__.py</code> <pre><code>def validate(self, value: str) -&gt; None:\n    \"\"\"Validates `value` against this type's constraints.\n    Raises AamlError on failure.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#primitive-types","level":2,"title":"Primitive Types","text":"","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.primitive_type.PrimitiveType","level":2,"title":"<code>aam_py.types.primitive_type.PrimitiveType</code>","text":"Source code in <code>aam_py/types/primitive_type.py</code> <pre><code>class PrimitiveType(Type, Enum):\n    I32 = \"i32\"\n    F64 = \"f64\"\n    STRING = \"string\"\n    BOOL = \"bool\"\n    COLOR = \"color\"\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; 'Type':\n        for pt in cls:\n            if pt.value == name:\n                return pt\n        raise NotFoundError(name)\n\n    def base_type(self) -&gt; 'PrimitiveType':\n        return self\n\n    def validate(self, value: str) -&gt; None:\n        if self == PrimitiveType.I32:\n            try:\n                int(value)\n            except ValueError:\n                raise InvalidValueError(f\"Expected i32, got '{value}'\")\n        elif self == PrimitiveType.F64:\n            try:\n                float(value)\n            except ValueError:\n                raise InvalidValueError(f\"Expected f64, got '{value}'\")\n        elif self == PrimitiveType.STRING:\n            pass  # Any string is valid\n        elif self == PrimitiveType.BOOL:\n            lowered = value.lower()\n            if lowered not in (\"true\", \"false\", \"1\", \"0\"):\n                raise InvalidValueError(f\"Expected bool (true/false/1/0), got '{value}'\")\n        elif self == PrimitiveType.COLOR:\n            if not value.startswith('#') or len(value) not in (7, 9):\n                raise InvalidValueError(f\"Expected color in #RRGGBB or #RRGGBBAA format, got '{value}'\")\n            try:\n                int(value[1:], 16)\n            except ValueError:\n                raise InvalidValueError(f\"Invalid hex color '{value}'\")\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#math-types","level":2,"title":"Math Types","text":"","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.math.MathTypes","level":2,"title":"<code>aam_py.types.math.MathTypes</code>","text":"Source code in <code>aam_py/types/math.py</code> <pre><code>class MathTypes(Type, Enum):\n    VECTOR2 = \"vector2\"\n    VECTOR3 = \"vector3\"\n    VECTOR4 = \"vector4\"\n    QUATERNION = \"quaternion\"\n    MATRIX3X3 = \"matrix3x3\"\n    MATRIX4X4 = \"matrix4x4\"\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; 'Type':\n        for mt in cls:\n            if mt.value == name:\n                return mt\n        raise NotFoundError(name)\n\n    def base_type(self) -&gt; 'PrimitiveType':\n        return PrimitiveType.F64\n\n    def validate(self, value: str) -&gt; None:\n        parts = [p.strip() for p in value.split(',')]\n\n        expected_len = 0\n        if self == MathTypes.VECTOR2:\n            expected_len = 2\n        elif self == MathTypes.VECTOR3:\n            expected_len = 3\n        elif self in (MathTypes.VECTOR4, MathTypes.QUATERNION):\n            expected_len = 4\n        elif self == MathTypes.MATRIX3X3:\n            expected_len = 9\n        elif self == MathTypes.MATRIX4X4:\n            expected_len = 16\n\n        if len(parts) != expected_len:\n            raise InvalidValueError(f\"Expected {expected_len} components, got {len(parts)}\")\n\n        for part in parts:\n            try:\n                float(part)\n            except ValueError:\n                raise InvalidValueError(f\"Invalid number: {part}\")\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#time-types","level":2,"title":"Time Types","text":"","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.time.TimeTypes","level":2,"title":"<code>aam_py.types.time.TimeTypes</code>","text":"Source code in <code>aam_py/types/time.py</code> <pre><code>class TimeTypes(Type, Enum):\n    DATETIME = \"datetime\"\n    DURATION = \"duration\"\n    YEAR = \"year\"\n    DAY = \"day\"\n    HOUR = \"hour\"\n    MINUTE = \"minute\"\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; 'Type':\n        for tt in cls:\n            if tt.value == name:\n                return tt\n        raise NotFoundError(name)\n\n    def base_type(self) -&gt; 'PrimitiveType':\n        return PrimitiveType.F64\n\n    def validate(self, value: str) -&gt; None:\n        if self == TimeTypes.DATETIME:\n            validate_datetime(value)\n        elif self == TimeTypes.DURATION:\n            if value.startswith('P'):\n                pass  # ISO 8601 duration\n            else:\n                validate_numeric(value, \"Duration\")\n        elif self == TimeTypes.YEAR:\n            validate_numeric(value, \"Year\")\n        elif self == TimeTypes.DAY:\n            validate_numeric(value, \"Day\")\n        elif self == TimeTypes.HOUR:\n            validate_numeric(value, \"Hour\")\n        elif self == TimeTypes.MINUTE:\n            validate_numeric(value, \"Minute\")\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#physics-types","level":2,"title":"Physics Types","text":"","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.physics.PhysicsTypes","level":2,"title":"<code>aam_py.types.physics.PhysicsTypes</code>","text":"Source code in <code>aam_py/types/physics.py</code> <pre><code>class PhysicsTypes(Type):\n    __slots__ = ('name',)\n\n    def __init__(self, name: str):\n        self.name = name\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; 'Type':\n        search = name.lower().replace('_', '').replace('-', '')\n        if search in PHYSICS_TYPES_MAP:\n            return cls(PHYSICS_TYPES_MAP[search])\n        raise NotFoundError(name)\n\n    def base_type(self) -&gt; 'PrimitiveType':\n        if self.name in (\"Bit\", \"Byte\", \"Baud\"):\n            return PrimitiveType.I32\n        return PrimitiveType.F64\n\n    def validate(self, value: str) -&gt; None:\n        base = self.base_type()\n        if base == PrimitiveType.I32:\n            try:\n                int(value)\n            except ValueError:\n                raise InvalidValueError(f\"Expected integer for unit {self.name}, got '{value}'\")\n        elif base == PrimitiveType.F64:\n            try:\n                float(value)\n            except ValueError:\n                raise InvalidValueError(f\"Expected number for unit {self.name}, got '{value}'\")\n        else:\n            raise InvalidValueError(f\"Unsupported base type for unit {self.name}\")\n\n    def __str__(self):\n        # Return snake_case version possibly if requested, but for simplicity matching rust output\n        # Rust format is the variant name formatted with camelCase\n        return self.name[0].lower() + self.name[1:]\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#list-types","level":2,"title":"List Types","text":"","path":["API Reference","Types"],"tags":[]},{"location":"api/types/#aam_py.types.list.ListType","level":2,"title":"<code>aam_py.types.list.ListType</code>","text":"Source code in <code>aam_py/types/list.py</code> <pre><code>class ListType(Type):\n    __slots__ = ('inner_type',)\n\n    def __init__(self, inner_type: str):\n        self.inner_type = inner_type\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; 'Type':\n        raise NotFoundError(\"ListType.from_name — use ListType() instead\")\n\n    def base_type(self) -&gt; 'Type':\n        return PrimitiveType.STRING\n\n    @staticmethod\n    def parse_inner(type_str: str) -&gt; Optional[str]:\n        t = type_str.strip()\n        if t.startswith(\"list&lt;\") and t.endswith(\"&gt;\"):\n            inner = t[5:-1].strip()\n            if inner:\n                return inner\n        return None\n\n    @staticmethod\n    def parse_items(value: str) -&gt; Optional[List[str]]:\n        t = value.strip()\n        if t.startswith(\"[\") and t.endswith(\"]\"):\n            inner = t[1:-1].strip()\n            return split_top_level(inner)\n        return None\n\n    def validate(self, value: str) -&gt; None:\n        items = self.parse_items(value)\n        if items is None:\n            raise InvalidValueError(f\"Expected a list literal in the form [item, item, ...], got '{value}'\")\n\n        from aam_py.types import resolve_builtin\n        try:\n            inner = resolve_builtin(self.inner_type)\n        except AamlError:\n            raise NotFoundError(f\"Unknown list element type '{self.inner_type}'\")\n\n        for item in items:\n            try:\n                inner.validate(item)\n            except AamlError as e:\n                raise InvalidValueError(f\"List item '{item}' failed validation for type '{self.inner_type}': {e}\")\n</code></pre>","path":["API Reference","Types"],"tags":[]},{"location":"api/validation/","level":1,"title":"Validation","text":"","path":["API Reference","Validation"],"tags":[]},{"location":"api/validation/#validation-utilities","level":2,"title":"Validation Utilities","text":"","path":["API Reference","Validation"],"tags":[]},{"location":"api/validation/#aam_py.validation","level":2,"title":"<code>aam_py.validation</code>","text":"","path":["API Reference","Validation"],"tags":[]}]}